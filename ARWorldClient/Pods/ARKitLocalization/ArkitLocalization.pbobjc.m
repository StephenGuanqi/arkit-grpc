// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arkit_localization.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ArkitLocalization.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ARLArkitLocalizationRoot

@implementation ARLArkitLocalizationRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ARLArkitLocalizationRoot_FileDescriptor

static GPBFileDescriptor *ARLArkitLocalizationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"arkitlocalization"
                                                 objcPrefix:@"ARL"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ARLARInfo

@implementation ARLARInfo

@dynamic hasArImage, arImage;
@dynamic hasArWorldTransform, arWorldTransform;

typedef struct ARLARInfo__storage_ {
  uint32_t _has_storage_[1];
  ARLARKitImage *arImage;
  ARLARKitCameraPos *arWorldTransform;
} ARLARInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "arImage",
        .dataTypeSpecific.className = GPBStringifySymbol(ARLARKitImage),
        .number = ARLARInfo_FieldNumber_ArImage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ARLARInfo__storage_, arImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "arWorldTransform",
        .dataTypeSpecific.className = GPBStringifySymbol(ARLARKitCameraPos),
        .number = ARLARInfo_FieldNumber_ArWorldTransform,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ARLARInfo__storage_, arWorldTransform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ARLARInfo class]
                                     rootClass:[ARLArkitLocalizationRoot class]
                                          file:ARLArkitLocalizationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ARLARInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ARLARKitImage

@implementation ARLARKitImage

@dynamic pixeBuffer;
@dynamic timestamp;

typedef struct ARLARKitImage__storage_ {
  uint32_t _has_storage_[1];
  NSData *pixeBuffer;
  double timestamp;
} ARLARKitImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pixeBuffer",
        .dataTypeSpecific.className = NULL,
        .number = ARLARKitImage_FieldNumber_PixeBuffer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ARLARKitImage__storage_, pixeBuffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ARLARKitImage_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ARLARKitImage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ARLARKitImage class]
                                     rootClass:[ARLArkitLocalizationRoot class]
                                          file:ARLArkitLocalizationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ARLARKitImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ARLARKitCameraPos

@implementation ARLARKitCameraPos

@dynamic mArray, mArray_Count;

typedef struct ARLARKitCameraPos__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *mArray;
} ARLARKitCameraPos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mArray",
        .dataTypeSpecific.className = NULL,
        .number = ARLARKitCameraPos_FieldNumber_MArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ARLARKitCameraPos__storage_, mArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ARLARKitCameraPos class]
                                     rootClass:[ARLArkitLocalizationRoot class]
                                          file:ARLArkitLocalizationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ARLARKitCameraPos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ARLARWorld2World

@implementation ARLARWorld2World

@dynamic mArray, mArray_Count;

typedef struct ARLARWorld2World__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *mArray;
} ARLARWorld2World__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mArray",
        .dataTypeSpecific.className = NULL,
        .number = ARLARWorld2World_FieldNumber_MArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ARLARWorld2World__storage_, mArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ARLARWorld2World class]
                                     rootClass:[ARLArkitLocalizationRoot class]
                                          file:ARLArkitLocalizationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ARLARWorld2World__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ARLServerResponse

@implementation ARLServerResponse

@dynamic succeed;

typedef struct ARLServerResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t succeed;
} ARLServerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "succeed",
        .dataTypeSpecific.className = NULL,
        .number = ARLServerResponse_FieldNumber_Succeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ARLServerResponse__storage_, succeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ARLServerResponse class]
                                     rootClass:[ARLArkitLocalizationRoot class]
                                          file:ARLArkitLocalizationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ARLServerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
